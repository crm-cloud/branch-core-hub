import { supabase } from '@/integrations/supabase/client';
import type { Database } from '@/integrations/supabase/types';

type Locker = Database['public']['Tables']['lockers']['Row'];
type LockerAssignment = Database['public']['Tables']['locker_assignments']['Row'];
type LockerStatus = Database['public']['Enums']['locker_status'];

export interface LockerWithAssignment extends Locker {
  locker_assignments?: (LockerAssignment & {
    members?: {
      member_code: string;
      user_id: string | null;
    } | null;
  })[];
}

export const lockerService = {
  // Get all lockers for a branch
  async getLockers(branchId: string): Promise<LockerWithAssignment[]> {
    const { data, error } = await supabase
      .from('lockers')
      .select(`
        *,
        locker_assignments (
          *,
          members (
            member_code,
            user_id
          )
        )
      `)
      .eq('branch_id', branchId)
      .order('locker_number');

    if (error) throw error;
    return data as LockerWithAssignment[];
  },

  // Get available lockers
  async getAvailableLockers(branchId: string) {
    const { data, error } = await supabase
      .from('lockers')
      .select('*')
      .eq('branch_id', branchId)
      .eq('status', 'available')
      .order('locker_number');

    if (error) throw error;
    return data;
  },

  // Create a locker
  async createLocker(locker: {
    branch_id: string;
    locker_number: string;
    size?: string;
    monthly_fee?: number;
    notes?: string;
  }) {
    const { data, error } = await supabase
      .from('lockers')
      .insert({
        ...locker,
        status: 'available' as LockerStatus,
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Update locker
  async updateLocker(lockerId: string, updates: Partial<Locker>) {
    const { data, error } = await supabase
      .from('lockers')
      .update(updates)
      .eq('id', lockerId)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Assign locker to member
  async assignLocker(assignment: {
    locker_id: string;
    member_id: string;
    start_date: string;
    end_date?: string;
    fee_amount?: number;
  }) {
    // Start a transaction-like operation
    const { data: locker, error: lockerError } = await supabase
      .from('lockers')
      .update({ status: 'occupied' as LockerStatus })
      .eq('id', assignment.locker_id)
      .select()
      .single();

    if (lockerError) throw lockerError;

    const { data, error } = await supabase
      .from('locker_assignments')
      .insert({
        ...assignment,
        is_active: true,
      })
      .select()
      .single();

    if (error) {
      // Rollback locker status
      await supabase
        .from('lockers')
        .update({ status: 'available' as LockerStatus })
        .eq('id', assignment.locker_id);
      throw error;
    }

    return data;
  },

  // Release locker
  async releaseLocker(assignmentId: string, lockerId: string) {
    const { error: assignError } = await supabase
      .from('locker_assignments')
      .update({ 
        is_active: false,
        end_date: new Date().toISOString().split('T')[0],
      })
      .eq('id', assignmentId);

    if (assignError) throw assignError;

    const { error: lockerError } = await supabase
      .from('lockers')
      .update({ status: 'available' as LockerStatus })
      .eq('id', lockerId);

    if (lockerError) throw lockerError;

    return { success: true };
  },

  // Get member's active locker assignment
  async getMemberLocker(memberId: string) {
    const { data, error } = await supabase
      .from('locker_assignments')
      .select(`
        *,
        lockers (*)
      `)
      .eq('member_id', memberId)
      .eq('is_active', true)
      .single();

    if (error && error.code !== 'PGRST116') throw error;
    return data;
  },

  // Create locker invoice
  async createLockerInvoice(
    memberId: string,
    branchId: string,
    lockerId: string,
    lockerNumber: string,
    amount: number,
    months: number = 1
  ) {
    // First create the invoice
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        branch_id: branchId,
        member_id: memberId,
        invoice_number: '', // Will be generated by trigger
        subtotal: amount,
        total_amount: amount,
        status: 'pending',
        due_date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      })
      .select()
      .single();

    if (invoiceError) throw invoiceError;

    // Add invoice item
    const { error: itemError } = await supabase
      .from('invoice_items')
      .insert({
        invoice_id: invoice.id,
        description: `Locker #${lockerNumber} rental (${months} month${months > 1 ? 's' : ''})`,
        unit_price: amount / months,
        quantity: months,
        total_amount: amount,
        reference_type: 'locker',
        reference_id: lockerId,
      });

    if (itemError) throw itemError;

    return invoice;
  },
};
