import { supabase } from '@/integrations/supabase/client';
import type { 
  Membership, 
  MembershipWithPlan, 
  DaysRemaining, 
  PurchaseRequest,
  FreezeRequest 
} from '@/types/membership';
import { differenceInDays, addDays, parseISO, format, isAfter, isBefore } from 'date-fns';

export async function fetchMembership(membershipId: string) {
  const { data, error } = await supabase
    .from('memberships')
    .select('*, membership_plans(*)')
    .eq('id', membershipId)
    .single();

  if (error) throw error;
  return data as MembershipWithPlan;
}

export async function fetchMemberMemberships(memberId: string) {
  const { data, error } = await supabase
    .from('memberships')
    .select('*, membership_plans(*)')
    .eq('member_id', memberId)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data as MembershipWithPlan[];
}

export async function fetchActiveMembership(memberId: string) {
  const { data, error } = await supabase
    .from('memberships')
    .select('*, membership_plans(*)')
    .eq('member_id', memberId)
    .eq('status', 'active')
    .gte('end_date', format(new Date(), 'yyyy-MM-dd'))
    .order('end_date', { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) throw error;
  return data as MembershipWithPlan | null;
}

export function calculateDaysRemaining(membership: Membership): DaysRemaining {
  const today = new Date();
  const endDate = parseISO(membership.end_date);
  const startDate = parseISO(membership.start_date);
  
  const totalDays = differenceInDays(endDate, startDate);
  const daysUsed = differenceInDays(today, startDate);
  const frozenDays = membership.total_freeze_days_used || 0;
  const activeDaysRemaining = Math.max(0, differenceInDays(endDate, today));
  
  const isExpired = isAfter(today, endDate);
  const isFrozen = membership.status === 'frozen';

  return {
    total: totalDays,
    frozen: frozenDays,
    active: activeDaysRemaining,
    isExpired,
    isFrozen,
  };
}

export async function purchaseMembership(request: PurchaseRequest) {
  const { memberId, planId, branchId, startDate, discountAmount, discountReason } = request;

  // Fetch the plan
  const { data: plan, error: planError } = await supabase
    .from('membership_plans')
    .select('*')
    .eq('id', planId)
    .single();

  if (planError) throw planError;

  // Calculate dates
  const start = parseISO(startDate);
  const endDate = format(addDays(start, plan.duration_days), 'yyyy-MM-dd');
  
  // Calculate price
  const basePrice = plan.discounted_price || plan.price;
  const admissionFee = plan.admission_fee || 0;
  const discount = discountAmount || 0;
  const pricePaid = basePrice + admissionFee - discount;

  // Create membership
  const { data: membership, error: membershipError } = await supabase
    .from('memberships')
    .insert({
      member_id: memberId,
      plan_id: planId,
      branch_id: branchId,
      start_date: startDate,
      end_date: endDate,
      original_end_date: endDate,
      price_paid: pricePaid,
      discount_amount: discount,
      discount_reason: discountReason,
      status: 'pending',
    })
    .select()
    .single();

  if (membershipError) throw membershipError;

  // Create invoice
  const { data: invoice, error: invoiceError } = await supabase
    .from('invoices')
    .insert({
      branch_id: branchId,
      member_id: memberId,
      invoice_number: '', // Will be auto-generated by trigger
      subtotal: basePrice + admissionFee,
      discount_amount: discount,
      tax_amount: 0,
      total_amount: pricePaid,
      status: 'pending',
      due_date: startDate,
    })
    .select()
    .single();

  if (invoiceError) throw invoiceError;

  // Create invoice items
  const items = [
    {
      invoice_id: invoice.id,
      description: `${plan.name} - ${plan.duration_days} days`,
      quantity: 1,
      unit_price: basePrice,
      total_amount: basePrice,
      reference_type: 'membership',
      reference_id: membership.id,
    },
  ];

  if (admissionFee > 0) {
    items.push({
      invoice_id: invoice.id,
      description: 'Admission Fee',
      quantity: 1,
      unit_price: admissionFee,
      total_amount: admissionFee,
      reference_type: 'admission_fee',
      reference_id: membership.id,
    });
  }

  const { error: itemsError } = await supabase.from('invoice_items').insert(items);
  if (itemsError) throw itemsError;

  return { membership, invoice };
}

export async function activateMembership(membershipId: string) {
  const { data, error } = await supabase
    .from('memberships')
    .update({ status: 'active' })
    .eq('id', membershipId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function requestFreeze(request: FreezeRequest) {
  const { membershipId, startDate, endDate, reason, isPaid } = request;

  const start = parseISO(startDate);
  const end = parseISO(endDate);
  const daysFrozen = differenceInDays(end, start) + 1;

  // Get branch settings for freeze fee
  const { data: membership } = await supabase
    .from('memberships')
    .select('branch_id')
    .eq('id', membershipId)
    .single();

  let feeCharged = 0;
  if (isPaid && membership) {
    const { data: settings } = await supabase
      .from('branch_settings')
      .select('freeze_fee')
      .eq('branch_id', membership.branch_id)
      .single();
    
    feeCharged = settings?.freeze_fee || 0;
  }

  const { data, error } = await supabase
    .from('membership_freeze_history')
    .insert({
      membership_id: membershipId,
      start_date: startDate,
      end_date: endDate,
      days_frozen: daysFrozen,
      reason,
      fee_charged: feeCharged,
      status: 'pending',
    })
    .select()
    .single();

  if (error) throw error;

  // Create approval request
  if (membership?.branch_id) {
    const { error: approvalError } = await supabase
      .from('approval_requests')
      .insert({
        branch_id: membership.branch_id,
        approval_type: 'membership_freeze' as const,
        reference_type: 'membership_freeze',
        reference_id: data.id,
        request_data: { membershipId, startDate, endDate, daysFrozen, reason, feeCharged },
      });

    if (approvalError) throw approvalError;
  }

  return data;
}

export async function approveFreeze(freezeId: string, approvedBy: string) {
  // Get freeze details
  const { data: freeze, error: freezeError } = await supabase
    .from('membership_freeze_history')
    .select('*, memberships(*)')
    .eq('id', freezeId)
    .single();

  if (freezeError) throw freezeError;

  // Update freeze status
  const { error: updateError } = await supabase
    .from('membership_freeze_history')
    .update({
      status: 'approved',
      approved_by: approvedBy,
      approved_at: new Date().toISOString(),
    })
    .eq('id', freezeId);

  if (updateError) throw updateError;

  // Update membership status to frozen if freeze starts today or earlier
  const today = new Date();
  const freezeStart = parseISO(freeze.start_date);
  
  if (!isAfter(freezeStart, today)) {
    await supabase
      .from('memberships')
      .update({ status: 'frozen' })
      .eq('id', freeze.membership_id);
  }

  return freeze;
}

export async function resumeFromFreeze(membershipId: string) {
  // Get the membership and its freeze history
  const { data: membership, error: membershipError } = await supabase
    .from('memberships')
    .select('*, membership_freeze_history(*)')
    .eq('id', membershipId)
    .single();

  if (membershipError) throw membershipError;

  // Calculate new end date based on frozen days
  const approvedFreezes = membership.membership_freeze_history?.filter(
    (f: any) => f.status === 'approved'
  ) || [];
  
  const totalFrozenDays = approvedFreezes.reduce(
    (sum: number, f: any) => sum + f.days_frozen,
    0
  );

  const originalEnd = parseISO(membership.original_end_date);
  const newEndDate = format(addDays(originalEnd, totalFrozenDays), 'yyyy-MM-dd');

  // Update membership
  const { data, error } = await supabase
    .from('memberships')
    .update({
      status: 'active',
      end_date: newEndDate,
      total_freeze_days_used: totalFrozenDays,
    })
    .eq('id', membershipId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function addFreeDays(membershipId: string, days: number, reason: string, addedBy: string) {
  // Check if membership has any discount
  const { data: membership, error: membershipError } = await supabase
    .from('memberships')
    .select('discount_amount')
    .eq('id', membershipId)
    .single();

  if (membershipError) throw membershipError;

  if (membership.discount_amount && membership.discount_amount > 0) {
    throw new Error('Cannot add free days to a membership that already has a discount applied');
  }

  // Add free days record
  const { data: freeDay, error: freeDayError } = await supabase
    .from('membership_free_days')
    .insert({
      membership_id: membershipId,
      days_added: days,
      reason,
      added_by: addedBy,
    })
    .select()
    .single();

  if (freeDayError) throw freeDayError;

  // Update membership end date
  const { data: currentMembership } = await supabase
    .from('memberships')
    .select('end_date')
    .eq('id', membershipId)
    .single();

  if (currentMembership) {
    const currentEnd = parseISO(currentMembership.end_date);
    const newEnd = format(addDays(currentEnd, days), 'yyyy-MM-dd');
    
    await supabase
      .from('memberships')
      .update({ end_date: newEnd })
      .eq('id', membershipId);
  }

  return freeDay;
}